<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>æˆ‘å€‘çš„è–èª•å©šç¦®é‚€è«‹</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #F0E6D2; 
            font-family: "Microsoft JhengHei", sans-serif;
            touch-action: none; 
        }
        canvas { display: block; }
        
        /* è¼‰å…¥ç•«é¢ */
        #loading-overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background-color: #F0E6D2;
            color: #880000;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5em;
            z-index: 100;
            transition: opacity 0.8s;
        }

        /* å€’æ•¸è¨ˆæ™‚å™¨ */
        #countdown {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: #880000;
            font-weight: bold;
            font-size: 1.1em;
            z-index: 10;
            padding: 5px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 5px;
        }

        /* å½ˆå‡ºè³‡è¨Šè¦–çª— */
        #info-modal {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none; 
            justify-content: center;
            align-items: center;
            z-index: 50;
        }
        #info-content {
            background: #F5F5DC;
            padding: 30px;
            border-radius: 10px;
            max-width: 80%;
            text-align: left;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            color: #333;
        }
        #info-content h3 {
            color: #880000;
            border-bottom: 2px solid #E6C35C;
            padding-bottom: 5px;
            margin-top: 0;
        }
        #info-content p {
            margin: 10px 0;
            font-size: 1.1em;
        }
        #info-content a {
            color: #007bff;
            text-decoration: none;
            font-weight: bold;
        }
        .close-btn {
            float: right;
            font-size: 2em;
            font-weight: bold;
            cursor: pointer;
            color: #880000;
        }
    </style>
</head>
<body>

<div id="loading-overlay">è¼‰å…¥æ¥µè‡´å¡ç‰‡æè³ªèˆ‡è–èª•ç‰¹æ•ˆä¸­...</div>
<div id="countdown"></div>

<div id="info-modal">
    <div id="info-content">
        <span class="close-btn">Ã—</span>
        <h3>ğŸ“ å©šå®´è³‡è¨Šè©³æƒ… ğŸ“</h3>
        
        <p><strong>åœ°é»ï½œ</strong>æ™¶å®´ãƒ»æ—¥å…‰é¦™é Œ</p>
        <p><strong>åœ°å€ï½œ</strong>å°åŒ—å¸‚ä¸­å±±å€æ°‘ç”Ÿæ±è·¯ä¸‰æ®µ 8 è™Ÿ 1 æ¨“</p>
        <p>
            <a href="https://maps.app.goo.gl/6mG21w1w3n3kE9499" target="_blank">ğŸ“Œ Google åœ°åœ–é€£çµ (åœ°é»)</a>
        </p>

        <hr style="border-top: 1px solid #ccc; margin: 15px 0;">

        <p><strong>åœè»Šè³‡è¨Šï½œ</strong>24TPS æ°¸å›ºä¾¿åˆ©åœè»Šå ´-æ°‘ç”Ÿç«™</p>
        <p><strong>åœè»Šå ´åœ°å€ï½œ</strong>10491 è‡ºåŒ—å¸‚ä¸­å±±å€æ°‘ç”Ÿæ±è·¯ä¸‰æ®µ 8 è™Ÿ B2 æ¨“</p>
        <p>
            <a href="https://maps.app.goo.gl/x7J9qFbLaP9hGD8NA" target="_blank">ğŸ…¿ï¸ Google åœ°åœ–é€£çµ (åœè»Šå ´)</a>
        </p>
        
    </div>
</div>

<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    let scene, camera, renderer, controls, cardMesh;
    const loadingOverlay = document.getElementById('loading-overlay');

    // å©šç¦®æ—¥æœŸ (ç›®æ¨™ï¼š12/25 12:00) - è«‹æ ¹æ“šå¯¦éš›å¹´ä»½ä¿®æ”¹
    const weddingDate = new Date("December 25, 2025 12:00:00").getTime(); 

    // å¡ç‰‡å°ºå¯¸ï¼š436x297 (æ©«å¼)
    const cardWidth = 4.36;
    const cardHeight = 2.97;
    const cardDepth = 0.015; 

    // è²¼åœ–è¼‰å…¥è¿½è¹¤
    let texturesLoaded = 0;
    // ç¸½å…± 5 å€‹è²¼åœ–ï¼šæ­£é¢åœ–ã€æ­£é¢ HDRã€èƒŒé¢åœ–ã€èƒŒé¢ HDRã€HDRç’°å¢ƒå…‰
    const totalTextures = 5;
    let frontBaseTexture, frontHdrTexture, backBaseTexture, backHdrTexture, envMapTexture;
    
    // è–èª•ç‰¹æ•ˆ
    let snowflakeSystem;
    const SNOWFLAKE_COUNT = 500;
    const SNOWFLAKE_RANGE = 15;

    // --- åˆå§‹åŒ–å‡½æ•¸ ---
    init();
    startCountdown(); 

    function init() {
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0xF0E6D2, 0.015);
        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 10);
        
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.useLegacyLights = false;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;
        document.body.appendChild(renderer.domElement);

        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.minDistance = 4;
        controls.maxDistance = 15;
        controls.enablePan = false;

        scene.add(new THREE.AmbientLight(0xffffff, 0.5));
        
        createSnowflakes();
        loadAllTextures();

        window.addEventListener('resize', onWindowResize);
        window.addEventListener('click', onCardClick, false);
        document.querySelector('.close-btn').onclick = () => {
            document.getElementById('info-modal').style.display = 'none';
        };
    }

    // --- è²¼åœ–è¼‰å…¥å®Œæˆæª¢æŸ¥ ---
    function textureReady(name) {
        texturesLoaded++;
        if (texturesLoaded === totalTextures) {
            createCard(frontBaseTexture, frontHdrTexture, backBaseTexture, backHdrTexture);
            animateIntro();
            loadingOverlay.style.opacity = 0;
            setTimeout(() => loadingOverlay.style.display = 'none', 800);
        }
    }
    
    // --- è¼‰å…¥æ‰€æœ‰å¤–éƒ¨è²¼åœ– ---
    function loadAllTextures() {
        const textureLoader = new THREE.TextureLoader();
        
        // 1. æ­£é¢ Base Color
        textureLoader.load('./photo_front.png', (texture) => { frontBaseTexture = texture; texture.colorSpace = THREE.SRGBColorSpace; textureReady('frontBaseTexture'); }, undefined, () => { console.error('front.png failed.'); frontBaseTexture = new THREE.Texture(); textureReady('frontBaseTexture'); });
        
        // 2. æ­£é¢ HDR (ç‡™é‡‘/å£“ç´‹è²¼åœ–)
        textureLoader.load('./textures/photo_front_hdr.jpg', (texture) => { frontHdrTexture = texture; textureReady('frontHdrTexture'); }, undefined, () => { console.error('front_hdr.jpg failed.'); frontHdrTexture = new THREE.Texture(); textureReady('frontHdrTexture'); });

        // 3. èƒŒé¢ Base Color
        textureLoader.load('./photo_back.png', (texture) => { backBaseTexture = texture; texture.colorSpace = THREE.SRGBColorSpace; textureReady('backBaseTexture'); }, undefined, () => { console.error('back.png failed.'); backBaseTexture = new THREE.Texture(); textureReady('backBaseTexture'); });
        
        // 4. èƒŒé¢ HDR (çç ç®”åå…‰è²¼åœ–)
        textureLoader.load('./textures/photo_back_hdr.jpg', (texture) => { backHdrTexture = texture; textureReady('backHdrTexture'); }, undefined, () => { console.error('back_hdr.jpg failed.'); backHdrTexture = new THREE.Texture(); textureReady('backHdrTexture'); });

        // 5. HDR ç’°å¢ƒè²¼åœ–
        textureLoader.load('./textures/hdr.jpg', (texture) => {
            const pmremGenerator = new THREE.PMREMGenerator(renderer);
            pmremGenerator.compileEquirectangularShader();
            envMapTexture = pmremGenerator.fromEquirectangular(texture).texture;
            scene.environment = envMapTexture;
            texture.dispose();
            pmremGenerator.dispose();
            textureReady('envMapTexture');
        }, undefined, () => { console.error('hdr.jpg failed.'); envMapTexture = null; textureReady('envMapTexture'); });
    }
    
    // --- å‰µå»ºå¡ç‰‡ ---
    function createCard(frontMap, frontHdr, backMap, backHdr) {
        const geometry = new THREE.BoxGeometry(cardWidth, cardHeight, cardDepth);
        
        // I. å´é¢æè³ª (é‡‘è‰²é‚Šç·£)
        const sideMaterial = new THREE.MeshPhysicalMaterial({ color: 0xFFD700, metalness: 1.0, roughness: 0.1, });

        // II. æ­£é¢æè³ª (ç´…è‰²éœ§é¢ç´™å¼µ + å‡¹é™·ç‡™é‡‘)
        // è²¼åœ–é‚è¼¯ï¼šå‡è¨­ front_hdr.jpg ä¸­é»‘è‰²å€åŸŸæ˜¯ç‡™é‡‘ï¼Œç™½è‰²å€åŸŸæ˜¯ç´™å¼µ
        const frontMaterial = new THREE.MeshPhysicalMaterial({
            map: frontMap,            // é¡è‰²è²¼åœ–
            color: 0x8A0000,          // å¼·åˆ¶åŸºåº•é¡è‰²ç‚ºæ·±ç´…
            
            // ç‡™é‡‘é‡‘å±¬ï¼šåœ–ä¸­é»‘(0) -> é«˜é‡‘å±¬(1)ï¼Œç™½(1) -> ç„¡é‡‘å±¬(0)
            metalnessMap: frontHdr,   
            metalness: 1.0,           

            // ç‡™é‡‘å…‰æ»‘ï¼šåœ–ä¸­é»‘(0) -> æ¥µåº¦å…‰æ»‘(0)ï¼Œç™½(1) -> ç²—ç³™ç´™å¼µ(1)
            roughnessMap: frontHdr,
            roughness: 0.8,           
            
            // å‡¹é™·æ•ˆæœï¼šé»‘è‰²ç‡™é‡‘å€åŸŸçœ‹èµ·ä¾†æ˜¯å£“ä¸‹å»çš„
            bumpMap: frontHdr,        
            bumpScale: -0.008         // è² å€¼æ¨¡æ“¬å‡¹é™· (å£“ç‡™é‡‘)
        });
        
        // III. èƒŒé¢æè³ª (ç±³è‰²äººç‰©åœ– + çç ç®”éŠ€è‰²åå…‰)
        const backMaterial = new THREE.MeshPhysicalMaterial({
            map: backMap,               // äººç‰©åœ–æ¡ˆ
            color: 0xF5F5DC,            // ç±³è‰²åº•
            
            // çç ç®”éŠ€å…‰ï¼šMetalness ä¸­ç­‰ï¼Œä½¿ç”¨ HDR åœ–æ§åˆ¶åå…‰å€åŸŸ
            metalness: 0.5,             // ä¸­ç­‰é‡‘å±¬åº¦ (éŠ€è‰²çç æ„Ÿ)

            // åå…‰è²¼åœ–æ§åˆ¶ï¼šåœ–ä¸­é¡è‰²æ·±çš„å€åŸŸæœƒè¼ƒç²—ç³™ï¼Œé¡è‰²æ·ºçš„å€åŸŸè¼ƒå…‰æ»‘
            roughnessMap: backHdr, 
            roughness: 0.6,             // åŸºç¤ç²—ç³™åº¦ï¼Œè®“æ•´é«”æè³ªæŸ”å’Œ
        });

        const materials = [
            sideMaterial, sideMaterial, sideMaterial, sideMaterial,
            frontMaterial, // Front (Index 4)
            backMaterial   // Back (Index 5)
        ];

        cardMesh = new THREE.Mesh(geometry, materials);
        cardMesh.scale.set(0.01, 0.01, 0.01);
        scene.add(cardMesh);
    }
    
    // --- å€’æ•¸è¨ˆæ™‚å™¨ ---
    function startCountdown() {
        // ... (ç¨‹å¼ç¢¼èˆ‡å‰ç‰ˆç›¸åŒ) ...
        const countdownEl = document.getElementById('countdown');
        const updateCountdown = () => {
            const now = new Date().getTime();
            const distance = weddingDate - now;

            if (distance < 0) {
                countdownEl.innerHTML = "ğŸ’– å©šç¦®é€²è¡Œä¸­ï¼";
                return;
            }

            const days = Math.floor(distance / (1000 * 60 * 60 * 24));
            const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
            const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((distance % (1000 * 60)) / 1000);

            countdownEl.innerHTML = `è–èª•å©šç¦®å€’æ•¸ï¼š${days} å¤© ${hours} å°æ™‚ ${minutes} åˆ† ${seconds} ç§’`;
        };

        updateCountdown();
        setInterval(updateCountdown, 1000);
    }

    // --- è–èª•é›ªèŠ±ç²’å­ç³»çµ± (èˆ‡å‰ç‰ˆç›¸åŒ) ---
    function createSnowflakes() {
        const geometry = new THREE.BufferGeometry();
        const vertices = [];

        for (let i = 0; i < SNOWFLAKE_COUNT; i++) {
            const x = THREE.MathUtils.randFloatSpread(SNOWFLAKE_RANGE * 2);
            const y = THREE.MathUtils.randFloat(0, SNOWFLAKE_RANGE);
            const z = THREE.MathUtils.randFloatSpread(SNOWFLAKE_RANGE * 2);
            vertices.push(x, y, z);
        }

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));

        const material = new THREE.PointsMaterial({
            color: 0xffffff, size: 0.1, transparent: true, opacity: 0.7, depthWrite: false 
        });

        snowflakeSystem = new THREE.Points(geometry, material);
        scene.add(snowflakeSystem);
    }
    
    // --- é»æ“Šäº‹ä»¶è™•ç† (èˆ‡å‰ç‰ˆç›¸åŒ) ---
    function onCardClick(event) {
        if (!cardMesh || !controls.enabled) return;

        const pointer = new THREE.Vector2();
        pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
        pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;

        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(pointer, camera);

        const intersects = raycaster.intersectObject(cardMesh);

        if (intersects.length > 0) {
            document.getElementById('info-modal').style.display = 'flex';
        }
    }

    // --- å¿ƒå‹•ç¬é–“é€²å ´å‹•ç•« (èˆ‡å‰ç‰ˆç›¸åŒ) ---
    function animateIntro() {
        const duration = 1500;
        const startTime = Date.now();
        
        const introLoop = () => {
            const elapsedTime = Date.now() - startTime;
            const t = Math.min(1, elapsedTime / duration);

            const scale = 0.01 + t * (1 - 0.01);
            cardMesh.scale.set(scale, scale, scale);

            const rotationY = Math.PI * 2 * (1 - Math.cos(t * Math.PI) / 2);

            cardMesh.rotation.y = rotationY;

            if (t < 1) {
                requestAnimationFrame(introLoop);
            } else {
                controls.enabled = true;
            }
        };

        controls.enabled = false;
        requestAnimationFrame(introLoop);
    }
    
    // --- æ¸²æŸ“ä¸»å¾ªç’° (é›ªèŠ±é£„è½èˆ‡è‡ªå‹•æ—‹è½‰) ---
    function animate() {
        requestAnimationFrame(animate);
        
        if (snowflakeSystem) {
            const positions = snowflakeSystem.geometry.attributes.position.array;
            for (let i = 1; i < positions.length; i += 3) {
                positions[i] -= 0.01; 
                
                if (positions[i] < -SNOWFLAKE_RANGE) {
                    positions[i] = SNOWFLAKE_RANGE;
                    positions[i - 1] = THREE.MathUtils.randFloatSpread(SNOWFLAKE_RANGE * 2); 
                    positions[i + 1] = THREE.MathUtils.randFloatSpread(SNOWFLAKE_RANGE * 2); 
                }
            }
            snowflakeSystem.geometry.attributes.position.needsUpdate = true;
        }
        
        if (cardMesh && controls.enabled && !controls.isRotating) {
            cardMesh.rotation.y += 0.0005; 
        }
        
        controls.update();
        renderer.render(scene, camera);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
</script>
</body>
</html>