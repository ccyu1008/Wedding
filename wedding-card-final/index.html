<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>我們的婚禮邀請</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #F0E6D2; 
            font-family: "Microsoft JhengHei", sans-serif;
            touch-action: none; /* 增強手機操作流暢性 */
        }
        canvas { display: block; }
        #loading-overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background-color: #F0E6D2;
            color: #880000;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5em;
            z-index: 100;
            transition: opacity 0.5s;
        }
    </style>
</head>
<body>

<div id="loading-overlay">載入愛的訊息中...</div>

<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    let scene, camera, renderer, controls, cardMesh;
    const loadingOverlay = document.getElementById('loading-overlay');

    // 卡片尺寸：根據您的 436x297 比例 (橫式)
    const cardWidth = 4.36;
    const cardHeight = 2.97;
    const cardDepth = 0.05;

    // 載入進度追蹤
    let texturesLoaded = 0;
    const totalTextures = 2; // 正面文字 + 背面人物 (HDR圖單獨處理)

    init();

    function init() {
        // 1. 場景
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0xF0E6D2, 0.015);

        // 2. 相機
        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 10);

        // 3. 渲染器
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.useLegacyLights = false;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;
        document.body.appendChild(renderer.domElement);

        // 4. 控制器
        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.minDistance = 4;
        controls.maxDistance = 15;
        controls.enablePan = false;
        
        // 5. 燈光與環境貼圖 (EnvMap)
        loadEnvironmentMap(() => {
            // 環境貼圖載入成功後，開始載入其他貼圖
            scene.add(new THREE.AmbientLight(0xffffff, 0.5));
            scene.add(new THREE.DirectionalLight(0xfff0dd, 2.0).position.set(2, 5, 8));
            
            loadCardTextures();
            animate();
        });
        
        window.addEventListener('resize', onWindowResize);
    }
    
    // --- 輔助函數：載入 HDR 環境光貼圖 ---
    function loadEnvironmentMap(callback) {
        const textureLoader = new THREE.TextureLoader();
        // 請確保 textures/hdr.jpg 存在！
        textureLoader.load('./textures/hdr.jpg', (texture) => {
            const pmremGenerator = new THREE.PMREMGenerator(renderer);
            pmremGenerator.compileEquirectangularShader();
            
            const envMap = pmremGenerator.fromEquirectangular(texture).texture;
            scene.environment = envMap; // 設定環境貼圖，提供反射光
            texture.dispose();
            pmremGenerator.dispose();
            console.log('Environment Map Loaded.');
            callback();
        }, undefined, (err) => {
            console.error('HDR Texture failed to load. Metal materials will not look right.', err);
            // 即使失敗也繼續
            scene.add(new THREE.AmbientLight(0xffffff, 1.0));
            callback(); 
        });
    }

    // --- 輔助函數：貼圖載入完成檢查 ---
    function textureReady() {
        texturesLoaded++;
        if (texturesLoaded === totalTextures) {
            // 所有貼圖載入完成，隱藏讀取畫面
            loadingOverlay.style.opacity = 0;
            setTimeout(() => loadingOverlay.style.display = 'none', 500);
        }
    }

    // --- 橫式正面文字設計 ---
    function createFrontTextTexture() {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        // 高解析度畫布
        canvas.width = 1744; 
        canvas.height = 1188;

        // 1. 背景色 (深紅)
        ctx.fillStyle = '#8A0000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // 2. 邊框裝飾
        ctx.strokeStyle = '#E6C35C'; 
        ctx.lineWidth = 15;
        const margin = 60;
        ctx.strokeRect(margin, margin, canvas.width - margin*2, canvas.height - margin*2);

        // 3. 文字設定 (燙金黃色)
        ctx.fillStyle = '#E6C35C';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;

        ctx.font = 'bold 70px "Microsoft JhengHei", serif';
        ctx.fillText("今年聖誕節我們要交換的禮物", centerX, centerY - 120);
        
        ctx.font = 'bold 90px "Microsoft JhengHei", serif';
        ctx.fillText("是一輩子承諾！", centerX, centerY - 20);
        
        ctx.font = '50px "Microsoft JhengHei", sans-serif';
        ctx.fillText("我們交往十年了！", centerX, centerY + 100);
        
        ctx.font = '40px "Microsoft JhengHei", sans-serif';
        ctx.fillText("有您的祝福才是最完美的日子！", centerX, centerY + 200);

        const texture = new THREE.CanvasTexture(canvas);
        texture.colorSpace = THREE.SRGBColorSpace;
        textureReady(); // 標記正面貼圖完成
        return texture;
    }

    function loadCardTextures() {
        const textureLoader = new THREE.TextureLoader();
        
        // 1. 產生正面文字貼圖
        const frontTexture = createFrontTextTexture();
        
        // 2. 載入背面人物貼圖
        // 檔案名稱：photo_back.png
        textureLoader.load('./photo_back.png', (backTexture) => {
            backTexture.colorSpace = THREE.SRGBColorSpace;
            createCard(frontTexture, backTexture);
            textureReady(); // 標記背面貼圖完成
        }, undefined, (err) => {
            // 提醒使用者檔案不存在
            console.error("Back photo failed to load. Please check if photo_back.png exists.", err);
            loadingOverlay.textContent = "錯誤：找不到 photo_back.png 檔案！";
            // 使用純色米色作為替代
            const blankTexture = new THREE.Texture();
            createCard(frontTexture, blankTexture);
            textureReady();
        });
    }

    function createCard(frontTexture, backTexture) {
        const geometry = new THREE.BoxGeometry(cardWidth, cardHeight, cardDepth);

        // 1. 側面材質 (極致金屬金色)
        const sideMaterial = new THREE.MeshPhysicalMaterial({
            color: 0xFFD700,
            metalness: 1.0, 
            roughness: 0.1, 
        });

        // 2. 正面材質 (紅色燙金)
        const frontMaterial = new THREE.MeshPhysicalMaterial({
            map: frontTexture,
            color: 0xffffff,
            metalness: 0.8,    // 高度金屬光澤
            roughness: 0.2,    // 光滑
            clearcoat: 1.0,    // 高光漆層
            clearcoatRoughness: 0.05,
        });

        // 3. 背面材質 (米色底 + 銀色反光人物)
        let backMaterial;
        
        // 檢查背面貼圖是否為有效圖片
        if (backTexture.image) {
            // 有效貼圖：使用粗糙度貼圖實現銀色反光
            backMaterial = new THREE.MeshPhysicalMaterial({
                color: 0xF5F5DC,           // 米色底
                map: backTexture,          
                roughnessMap: backTexture, // 核心：黑色線條/網點會變光滑
                metalness: 0.85,           // 高金屬度，讓光滑區域像銀色
                roughness: 1.0,            // 基礎粗糙度設為 1，完全依賴貼圖控制
            });
        } else {
            // 貼圖失敗：使用帶有粗糙感的米色材質
            backMaterial = new THREE.MeshPhysicalMaterial({
                color: 0xF5F5DC,
                metalness: 0.05,
                roughness: 0.7, // 粗糙紙張質感
            });
        }

        const materials = [
            sideMaterial, sideMaterial, sideMaterial, sideMaterial,
            frontMaterial, // Front (Index 4)
            backMaterial   // Back (Index 5)
        ];

        cardMesh = new THREE.Mesh(geometry, materials);
        scene.add(cardMesh);

        // 初始角度：讓它面對賓客，並稍微傾斜
        cardMesh.rotation.y = 0.2;
        cardMesh.rotation.x = -0.1; 
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);
        
        // 緩慢自動旋轉
        if (cardMesh) {
            cardMesh.rotation.y += 0.002;
        }
        
        controls.update();
        renderer.render(scene, camera);
    }
</script>
</body>
</html>