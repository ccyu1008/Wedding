<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>æˆ‘å€‘çš„å©šç¦®é‚€è«‹</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #F0E6D2; /* ç±³è‰²èƒŒæ™¯ */
            font-family: "Microsoft JhengHei", sans-serif;
        }
        canvas { display: block; }
        
        /* è¼‰å…¥èˆ‡æŒ‰éˆ•ä»‹é¢ */
        #ui-container {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 10;
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        #loading-text {
            color: #880000;
            font-size: 1.2em;
            margin-bottom: 15px;
        }
        /* è‡ªè¨‚ä¸Šå‚³æŒ‰éˆ•æ¨£å¼ */
        .custom-file-upload {
            display: inline-block;
            padding: 10px 20px;
            cursor: pointer;
            background-color: #880000;
            color: white;
            border-radius: 5px;
            font-size: 16px;
            border: 1px solid #660000;
        }
        .custom-file-upload:hover {
            background-color: #a00000;
        }
        input[type="file"] {
            display: none;
        }
        #hint {
            font-size: 0.9em;
            color: #666;
            margin-top: 10px;
        }
    </style>
</head>
<body>

<div id="ui-container">
    <div id="loading-text">æ­£åœ¨å°‹æ‰¾ç…§ç‰‡...</div>
    
    <label for="file-upload" class="custom-file-upload">
        ğŸ“‚ é»æ­¤é¸æ“‡æ‚¨çš„ photo_back.png
    </label>
    <input id="file-upload" type="file" accept="image/png, image/jpeg"/>
    
    <div id="hint">è‹¥è‡ªå‹•è¼‰å…¥å¤±æ•—ï¼Œè«‹æ‰‹å‹•é¸æ“‡ç…§ç‰‡</div>
</div>

<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    let scene, camera, renderer, controls, cardMesh;
    const uiContainer = document.getElementById('ui-container');
    const loadingText = document.getElementById('loading-text');

    // è¨­å®šå¡ç‰‡å°ºå¯¸ï¼šæ ¹æ“šæ‚¨çš„ 436x297 æ¯”ä¾‹
    // æˆ‘å€‘å°‡å…¶é™¤ä»¥ 100 è½‰ç‚º 3D å–®ä½ï¼Œç´„ 4.36 x 2.97
    const cardWidth = 4.36;
    const cardHeight = 2.97;
    const cardDepth = 0.05; // è–„ä¸€é»æ¯”è¼ƒåƒå¡ç‰‡

    init();

    function init() {
        // 1. å ´æ™¯
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0xF0E6D2, 0.015);

        // 2. ç›¸æ©Ÿ
        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 10); // è·é›¢é©ä¸­

        // 3. æ¸²æŸ“å™¨
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.useLegacyLights = false;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // 4. æ§åˆ¶å™¨
        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.minDistance = 4;
        controls.maxDistance = 15;
        controls.enablePan = false;

        // 5. ç‡ˆå…‰ (èª¿æ•´ç‚ºé©åˆæ©«å¼å¡ç‰‡)
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const mainLight = new THREE.DirectionalLight(0xfff0dd, 2.0);
        mainLight.position.set(2, 5, 8);
        mainLight.castShadow = true;
        mainLight.shadow.mapSize.width = 1024; 
        mainLight.shadow.mapSize.height = 1024;
        scene.add(mainLight);

        // å´é¢èˆ‡èƒŒé¢çš„è£œå…‰
        const sideLight = new THREE.PointLight(0xffd700, 2);
        sideLight.position.set(6, 0, 2);
        scene.add(sideLight);

        const backLight = new THREE.SpotLight(0xffffff, 3);
        backLight.position.set(0, 2, -10);
        backLight.lookAt(0,0,0);
        scene.add(backLight);

        // 6. å˜—è©¦è‡ªå‹•è¼‰å…¥åœ–ç‰‡
        attemptLoadImage('./photo_back.png');

        // ç›£è½æ‰‹å‹•ä¸Šå‚³æŒ‰éˆ•
        document.getElementById('file-upload').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const objectURL = URL.createObjectURL(file);
                attemptLoadImage(objectURL);
            }
        });

        window.addEventListener('resize', onWindowResize);
        animate();
    }

    function attemptLoadImage(url) {
        const textureLoader = new THREE.TextureLoader();
        textureLoader.load(
            url,
            function(texture) {
                // æˆåŠŸè¼‰å…¥
                uiContainer.style.display = 'none'; // éš±è— UI
                createCard(texture);
            },
            undefined,
            function(err) {
                // è¼‰å…¥å¤±æ•— (é€šå¸¸æ˜¯ CORS å•é¡Œæˆ–æª”æ¡ˆä¸å­˜åœ¨)
                console.warn("è‡ªå‹•è¼‰å…¥å¤±æ•—ï¼Œç­‰å¾…ä½¿ç”¨è€…æ‰‹å‹•é¸æ“‡æª”æ¡ˆ");
                loadingText.textContent = "ç„¡æ³•è‡ªå‹•è®€å– (å¯èƒ½æ˜¯å®‰å…¨é™åˆ¶)";
            }
        );
    }

    // --- æ©«å¼æ­£é¢æ–‡å­—è¨­è¨ˆ ---
    function createFrontTextTexture() {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        // è¨­å®šé«˜è§£æåº¦ç•«å¸ƒ (436x297 çš„ 4 å€è§£æåº¦)
        canvas.width = 1744; 
        canvas.height = 1188;

        // 1. èƒŒæ™¯è‰² (æ·±ç´…)
        ctx.fillStyle = '#8A0000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // 2. é‚Šæ¡†è£é£¾
        ctx.strokeStyle = '#E6C35C'; // ç‡™é‡‘è‰²
        ctx.lineWidth = 15;
        const margin = 60;
        ctx.strokeRect(margin, margin, canvas.width - margin*2, canvas.height - margin*2);
        // å…§åœˆç´°ç·š
        ctx.lineWidth = 3;
        ctx.strokeRect(margin + 20, margin + 20, canvas.width - (margin+20)*2, canvas.height - (margin+20)*2);

        // 3. æ–‡å­—è¨­å®š
        ctx.fillStyle = '#E6C35C';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;

        // ä¸»æ¨™é¡Œï¼šè–èª•äº¤æ›ç¦®ç‰©
        ctx.font = 'bold 70px "Microsoft JhengHei", serif';
        ctx.fillText("ä»Šå¹´è–èª•ç¯€æˆ‘å€‘è¦äº¤æ›çš„ç¦®ç‰©", centerX, centerY - 120);
        
        ctx.font = 'bold 90px "Microsoft JhengHei", serif';
        ctx.fillText("æ˜¯ä¸€è¼©å­æ‰¿è«¾ï¼", centerX, centerY - 20);
        
        // å‰¯æ¨™é¡Œ
        ctx.font = '50px "Microsoft JhengHei", sans-serif';
        ctx.fillText("æˆ‘å€‘äº¤å¾€åå¹´äº†ï¼", centerX, centerY + 100);
        
        // åº•éƒ¨ç¥ç¦
        ctx.font = '40px "Microsoft JhengHei", sans-serif';
        ctx.fillText("æœ‰æ‚¨çš„ç¥ç¦æ‰æ˜¯æœ€å®Œç¾çš„æ—¥å­ï¼", centerX, centerY + 200);

        const texture = new THREE.CanvasTexture(canvas);
        texture.colorSpace = THREE.SRGBColorSpace;
        return texture;
    }

    function createCard(backTexture) {
        // å¦‚æœå·²ç¶“æœ‰èˆŠçš„å¡ç‰‡ï¼Œå…ˆç§»é™¤ (ç‚ºäº†æ”¯æ´é‡æ–°ä¸Šå‚³)
        if (cardMesh) scene.remove(cardMesh);

        const geometry = new THREE.BoxGeometry(cardWidth, cardHeight, cardDepth);

        // 1. å´é¢æè³ª (é‡‘è‰²)
        const sideMaterial = new THREE.MeshPhysicalMaterial({
            color: 0xFFD700,
            metalness: 0.9,
            roughness: 0.2,
        });

        // 2. æ­£é¢æè³ª (ç´…è‰²ç‡™é‡‘æ–‡å­—)
        const frontTexture = createFrontTextTexture();
        const frontMaterial = new THREE.MeshPhysicalMaterial({
            map: frontTexture,
            color: 0xffffff,
            metalness: 0.6,
            roughness: 0.35, // ç¨å¾®ç²—ç³™ä¸€é»è®“å­—æ¯”è¼ƒæ¸…æ¥š
            clearcoat: 0.5,
            bumpMap: frontTexture, // æ–‡å­—å¾®å‡¸
            bumpScale: 0.03
        });

        // 3. èƒŒé¢æè³ª (ç±³è‰² + éŠ€è‰²åå…‰)
        backTexture.colorSpace = THREE.SRGBColorSpace;
        
        // ä¿®æ­£è²¼åœ–æ–¹å‘ï¼šå› ç‚º Canvas å’Œ Texture åº§æ¨™æœ‰æ™‚æœƒç›¸åï¼Œè‹¥åœ–ç‰‡ä¸Šä¸‹é¡›å€’ï¼Œå¯åœ¨æ­¤èª¿æ•´
        // backTexture.flipY = false; // è¦–æƒ…æ³é–‹å•Ÿ

        const backMaterial = new THREE.MeshPhysicalMaterial({
            color: 0xF5F5DC,           // ç±³è‰²åº•
            map: backTexture,          // é¡¯ç¤ºåœ–æ¡ˆ
            roughnessMap: backTexture, // é»‘è‰²è®Šå…‰æ»‘(éŠ€è‰²)ï¼Œç™½è‰²è®Šç²—ç³™
            metalness: 0.8,            // é‡‘å±¬åº¦é«˜ä¸€é»
            roughness: 1.0,            // åŸºç¤ç²—ç³™åº¦è¨­ç‚º 1
            envMapIntensity: 2.0       // å¢å¼·åå…‰
        });

        // æè³ªé™£åˆ— (å³, å·¦, ä¸Š, ä¸‹, å‰, å¾Œ)
        // æ³¨æ„ï¼šBoxGeometry çš„å‰å¾Œå®šç¾©å¯èƒ½å› è¦–è§’è€Œç•°ï¼Œé€šå¸¸ Index 4 æ˜¯å‰ (z+), 5 æ˜¯å¾Œ (z-)
        const materials = [
            sideMaterial, sideMaterial, sideMaterial, sideMaterial,
            frontMaterial, // Front
            backMaterial   // Back
        ];

        cardMesh = new THREE.Mesh(geometry, materials);
        cardMesh.castShadow = true;
        cardMesh.receiveShadow = true;
        scene.add(cardMesh);

        // åˆå§‹å‹•ç•«è§’åº¦
        cardMesh.rotation.y = Math.PI; // å…ˆè½‰èƒŒé¢çµ¦äººçœ‹ï¼Œæˆ–è€… 0 çœ‹æ­£é¢
        
        // é€²å ´å‹•ç•«ï¼šç¨å¾®è½‰ä¸€è½‰
        let startRot = 0;
        const introAnimate = () => {
            if (startRot < Math.PI / 6) {
                startRot += 0.01;
                cardMesh.rotation.y = -Math.PI / 6 + Math.sin(startRot);
                requestAnimationFrame(introAnimate);
            }
        };
        // introAnimate();
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);
        
        // ç·©æ…¢è‡ªå‹•æ—‹è½‰å±•ç¤ºæ•ˆæœ
        if (cardMesh) {
            cardMesh.rotation.y += 0.002;
        }
        
        controls.update();
        renderer.render(scene, camera);
    }
</script>
</body>
</html>